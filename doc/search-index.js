var searchIndex = {};
searchIndex['websocket'] = {"items":[[0,"","websocket","Rust-WebSocket is a WebSocket (RFC6455) library written in Rust.\n Rust-WebSocket attempts to provide a framework for WebSocket connections (both clients and servers).\n The library is currently in an experimental state, but can work as a simple WebSocket server or client,\n with the capability to send and receive fragmented messages.\n \n Rust-WebSocket does not provide a 'listener' object, since the WebSocket protocol utilises a TcpStream.\n To implement a WebSocket server, use a normal TcpListener, and the WebSocketClient::new() function\n on an accepted stream. You will then need to read the handshake from the client and send a response.\n \n ```no_run\n use std::io::TcpListener;\n use std::io::{Listener, Acceptor};\n use websocket::{WebSocketClient, WebSocketClientMode};\n use websocket::handshake::WebSocketResponse;\n \n let listener = TcpListener::bind(\"127.0.0.1:1234\");\n let mut acceptor = listener.listen();\n \n for stream in acceptor.incoming() {\n \tmatch stream {\n \t\tOk(stream) => {\n \t\t\t// Spawn a new task for each connection to run in parallel\n \t\t\tspawn(move || {\n \t\t\t\t// Get a WebSocketClient from this stream\n \t\t\t\tlet mut client = WebSocketClient::new(stream, WebSocketClientMode::RemoteClient); \n \t\t\t\t\n \t\t\t\t// Read the handshake from the client\n \t\t\t\tlet request = client.receive_handshake_request().unwrap();\n \t\t\t\t\n \t\t\t\t// Get the Sec-WebSocket-Key from the request\n \t\t\t\tlet key = request.key().unwrap();\n \t\t\t\t\n \t\t\t\t// Form a response from the key\n\t\t\t\t\t/* In this example, we don't deal with the requested Sec-WebSocket-Protocol.\n\t\t\t\t\t   Because of this, however, we need a type annotation, which would \n\t\t\t\t\t   not usually be required. */\n \t\t\t\tlet response = WebSocketResponse::new::<String>(key.as_slice(), None);\n \t\t\t\t\n \t\t\t\t// Send the response to the client\n \t\t\t\tlet _ = client.send_handshake_response(&response);\n \t\t\t\t\n \t\t\t\t// Now we can send and receive messages\n \t\t\t\tlet receiver = client.receiver();\n \t\t\t\tlet mut sender = client.sender();\n \t\t\t\t\n \t\t\t\t// ...\n \t\t\t});\n \t\t}\n \t\t_ => { /* A connection error occurred */ }\n \t}\n }\n ```"],[1,"WebSocketClient","","Represents a WebSocket client.\nTo use WebSocketClient, you must create one using WebSocketClient::new().\nFor a client, you can use TcpStream::connect() to connect to the server, then call\nWebSocketClient::new() passing the resultant stream.\n \n```no_run\nuse std::io::TcpStream;\nuse websocket::{WebSocketClient, WebSocketClientMode};\nuse websocket::handshake::WebSocketRequest;\n \nlet request = WebSocketRequest::new(\"ws://127.0.0.1:1234\", [\"myProtocol\"].as_slice()).unwrap();\nlet key = request.key().unwrap();"],[2,"WebSocketClientMode","",""],[12,"RemoteClient","","",0],[12,"RemoteServer","","",0],[0,"headers","","Structs for manipulation of HTTP headers. Used in conjunction with\nWebSocketRequest and WebSocketResponse."],[1,"HeaderCollection","websocket::headers","Represents a collection of HTTP headers"],[1,"Headers","","Iterates over the headers present in a HeaderCollection"],[10,"utf8","url::encoding","",1],[10,"lookup","","",1],[10,"is_utf8","","",1],[10,"decode","","",1],[10,"encode","","",1],[10,"clone","url::host","",2],[10,"clone_from","","",2],[10,"assert_receiver_is_total_eq","","",2],[10,"eq","","",2],[10,"ne","","",2],[10,"ne","","",2],[10,"eq","","",3],[10,"ne","","",3],[10,"ne","","",3],[10,"assert_receiver_is_total_eq","","",3],[10,"clone","","",3],[10,"clone_from","","",3],[10,"parse","","Parse a host: either an IPv6 address in [] square brackets, or a domain.",2],[10,"serialize","","Serialize the host as a string.",2],[10,"fmt","","",2],[10,"parse","","Parse an IPv6 address, without the [] square brackets.",3],[10,"serialize","","Serialize the IPv6 address to a string.",3],[10,"fmt","","",3],[10,"clone","url::parser","",4],[10,"clone_from","","",4],[10,"assert_receiver_is_total_eq","","",4],[10,"eq","","",4],[10,"ne","","",4],[10,"ne","","",4],[10,"description","","",4],[10,"detail","","",4],[10,"cause","","",4],[10,"fmt","","",4],[10,"assert_receiver_is_total_eq","","",5],[10,"eq","","",5],[10,"ne","","",5],[10,"ne","","",5],[10,"next","","",6],[10,"size_hint","","",6],[10,"fmt","url::format","",7],[10,"fmt","","",8],[10,"fmt","","",9],[10,"clone","url","",10],[10,"clone_from","","",10],[10,"assert_receiver_is_total_eq","","",10],[10,"eq","","",10],[10,"ne","","",10],[10,"ne","","",10],[10,"clone","","",11],[10,"clone_from","","",11],[10,"assert_receiver_is_total_eq","","",11],[10,"eq","","",11],[10,"ne","","",11],[10,"ne","","",11],[10,"clone","","",12],[10,"clone_from","","",12],[10,"assert_receiver_is_total_eq","","",12],[10,"eq","","",12],[10,"ne","","",12],[10,"ne","","",12],[10,"hash","","",10],[10,"new","","Return a new UrlParser with default parameters.",13],[10,"base_url","","Set the base URL used for resolving relative URL references, and return the `UrlParser`.\nThe default is no base URL, so that relative URLs references fail to parse.",13],[10,"error_handler","","Set an error handler for non-fatal parse errors, and return the `UrlParser`.",13],[10,"scheme_type_mapper","","Set a *scheme type mapper*, and return the `UrlParser`.",13],[10,"parse","","Parse `input` as an URL, with all the parameters previously set in the `UrlParser`.",13],[10,"parse_path","","Parse `input` as a “standalone” URL path,\nwith an optional query string and fragment identifier.",13],[10,"assert_receiver_is_total_eq","","",14],[10,"eq","","",14],[10,"ne","","",14],[10,"ne","","",14],[10,"default_port","","",14],[10,"parse","","Parse an URL with the default `UrlParser` parameters.",10],[10,"from_file_path","","Convert a file name as `std::path::Path` into an URL in the `file` scheme.",10],[10,"from_directory_path","","Convert a directory name as `std::path::Path` into an URL in the `file` scheme.",10],[10,"to_file_path","","Assuming the URL is in the `file` scheme or similar,\nconvert its path to an absolute `std::path::Path`.",10],[10,"serialize","","Return the serialization of this URL as a string.",10],[10,"serialize_no_fragment","","Return the serialization of this URL, without the fragment identifier, as a string",10],[10,"non_relative_scheme_data","","If the URL is *non-relative*, return the string scheme data.",10],[10,"non_relative_scheme_data_mut","","If the URL is *non-relative*, return a mutable reference to the string scheme data.",10],[10,"relative_scheme_data","","If the URL is in a *relative scheme*, return the structured scheme data.",10],[10,"relative_scheme_data_mut","","If the URL is in a *relative scheme*,\nreturn a mutable reference to the structured scheme data.",10],[10,"username","","If the URL is in a *relative scheme*, return its username.",10],[10,"username_mut","","If the URL is in a *relative scheme*, return a mutable reference to its username.",10],[10,"lossy_percent_decode_username","","Percent-decode the URL’s username, if any.",10],[10,"password","","If the URL is in a *relative scheme*, return its password, if any.",10],[10,"password_mut","","If the URL is in a *relative scheme*, return a mutable reference to its password, if any.",10],[10,"lossy_percent_decode_password","","Percent-decode the URL’s password, if any.",10],[10,"serialize_userinfo","","Serialize the URL's username and password, if any.",10],[10,"host","","If the URL is in a *relative scheme*, return its structured host.",10],[10,"host_mut","","If the URL is in a *relative scheme*, return a mutable reference to its structured host.",10],[10,"domain","","If the URL is in a *relative scheme* and its host is a domain,\nreturn the domain as a string.",10],[10,"domain_mut","","If the URL is in a *relative scheme* and its host is a domain,\nreturn a mutable reference to the domain string.",10],[10,"serialize_host","","If the URL is in a *relative scheme*, serialize its host as a string.",10],[10,"port","","If the URL is in a *relative scheme* and has a port number, return it.",10],[10,"port_mut","","If the URL is in a *relative scheme*, return a mutable reference to its port.",10],[10,"port_or_default","","If the URL is in a *relative scheme* that is not a file-like,\nreturn its port number, even if it is the default.",10],[10,"path","","If the URL is in a *relative scheme*, return its path components.",10],[10,"path_mut","","If the URL is in a *relative scheme*, return a mutable reference to its path components.",10],[10,"serialize_path","","If the URL is in a *relative scheme*, serialize its path as a string.",10],[10,"query_pairs","","Parse the URL’s query string, if any, as `application/x-www-form-urlencoded`\nand return a vector of (key, value) pairs.",10],[10,"set_query_from_pairs","","Serialize an iterator of (key, value) pairs as `application/x-www-form-urlencoded`\nand set it as the URL’s query string.",10],[10,"lossy_percent_decode_query","","Percent-decode the URL’s query string, if any.",10],[10,"lossy_percent_decode_fragment","","Percent-decode the URL’s fragment identifier, if any.",10],[10,"encode","","",10],[10,"decode","","",10],[10,"fmt","","",10],[10,"fmt","","",11],[10,"lossy_percent_decode_username","","Percent-decode the URL’s username.",12],[10,"lossy_percent_decode_password","","Percent-decode the URL’s password, if any.",12],[10,"to_file_path","","Assuming the URL is in the `file` scheme or similar,\nconvert its path to an absolute `std::path::Path`.",12],[10,"domain","","If the host is a domain, return the domain as a string.",12],[10,"domain_mut","","If the host is a domain, return a mutable reference to the domain string.",12],[10,"port_or_default","","Return the port number of the URL, even if it is the default.\nReturn `None` for file-like URLs.",12],[10,"serialize_path","","Serialize the path as a string.",12],[10,"serialize_userinfo","","Serialize the userinfo as a string.",12],[10,"fmt","","",12],[10,"to_url_path","std::path::posix","",15],[10,"to_url_path","std::path::windows","",16],[10,"from_url_path","std::path::posix","",15],[10,"from_url_path","std::path::windows","",16],[4,"ParseResult","websocket::headers",""],[2,"ParseError","","Errors that can occur during parsing."],[12,"EmptyHost","","",4],[12,"InvalidScheme","","",4],[12,"InvalidPort","","",4],[12,"InvalidIpv6Address","","",4],[12,"InvalidDomainCharacter","","",4],[12,"InvalidCharacter","","",4],[12,"InvalidBackslash","","",4],[12,"InvalidPercentEncoded","","",4],[12,"InvalidAtSymbolInUser","","",4],[12,"ExpectedTwoSlashes","","",4],[12,"ExpectedInitialSlash","","",4],[12,"NonUrlCodePoint","","",4],[12,"RelativeUrlWithScheme","","",4],[12,"RelativeUrlWithoutBase","","",4],[12,"RelativeUrlWithNonRelativeBase","","",4],[12,"NonAsciiDomainsNotSupportedYet","","",4],[12,"CannotSetJavascriptFragment","","",4],[12,"CannotSetPortWithFileLikeScheme","","",4],[12,"CannotSetUsernameWithNonRelativeScheme","","",4],[12,"CannotSetPasswordWithNonRelativeScheme","","",4],[12,"CannotSetHostPortWithNonRelativeScheme","","",4],[12,"CannotSetHostWithNonRelativeScheme","","",4],[12,"CannotSetPortWithNonRelativeScheme","","",4],[12,"CannotSetPathWithNonRelativeScheme","","",4],[0,"handshake","websocket","Structs for WebSocket handshake requests and responses"],[1,"WebSocketRequest","websocket::handshake","Represents a WebSocket handshake request, which is sent from the client to the server.\nUse the new() function to create a new request, and send it with the WebSocketClient::connect() function.\nUse the WebSocketClient.receive_handshake_request() method to read a WebSocketRequest from a remote client.\n \n```\nuse websocket::handshake::WebSocketRequest;"],[11,"resource_name","","The resource name of the request. E.g. /path/to/resource for the URI ws://www.example.com/path/to/resource",17],[11,"http_version","","The HTTP version of this request",17],[11,"headers","","The collection of headers contained in this request",17],[1,"WebSocketResponse","","Represents a WebSocket response which is sent from the server to the client.\nUse the new() function to create a new response, and send it with the WebSocketClient::send_handshake_response() function.\n \n```\nuse websocket::handshake::WebSocketResponse;"],[11,"http_version","","The HTTP version of this request",18],[11,"status_code","","The status code of the response (for a successful handshake, this should be 101)",18],[11,"reason_phrase","","The human readable reason phrase for the status code (E.g. Switching Protocols)",18],[11,"headers","","The collection of headers contained in this WebSocket response",18],[1,"HttpVersion","","Represents an HTTP version."],[11,"version_major","","The major HTTP version.",19],[11,"version_minor","","The minor HTTP version if present.",19],[0,"message","websocket","Structs for WebSocket messages and the transmission of messages"],[1,"WebSocketSender","websocket::message","Represents a WebSocket sender, capable of transmitting data to the remote endpoint.\nUse the send_message() method to send a single, whole message. If you need to send\na series of message fragments (e.g. if you need to send a message of unknown length),\nuse the fragment() method to obtain a WebSocketFragmentSerializer, which can be\nused to do so.\n \n```no_run\nuse websocket::message::WebSocketMessage;\n# use websocket::{WebSocketClient, WebSocketClientMode};\n# use std::io::TcpStream;\n# #[allow(unused_must_use)]\n# fn foo() {\n# let stream = TcpStream::connect(\"127.0.0.1:1234\").unwrap();\n# let mut client = WebSocketClient::new(stream, WebSocketClientMode::RemoteServer);\n \nlet mut sender = client.sender(); // Get a sender\nlet data = \"My fancy message\".to_string();\nlet message = WebSocketMessage::Text(data.to_string());\n \nlet _ = sender.send_message(&message); // Send the message\n# }\n```"],[1,"WebSocketFragmentSerializer","","Allows for the serialization of message fragments, to be sent to the remote endpoint.\nAny number of messages can be sent (but only text or binary messages, as control\nmessages can never be fragmented) using the send_fragment() method, and when the final\nfragment is to be sent, use the finish() method. After calling the finish method, the\nremote endpoint will assemble all of the received message fragments into a single\nmessage containing all of the fragment data concatenated together.\n \n```no_run\nuse websocket::message::WebSocketMessage;\n# use websocket::{WebSocketClient, WebSocketClientMode};\n# use std::io::TcpStream;\n# #[allow(unused_must_use)]\n# fn foo() {\n# let stream = TcpStream::connect(\"127.0.0.1:1234\").unwrap();\n# let mut client = WebSocketClient::new(stream, WebSocketClientMode::RemoteServer);\n# let mut sender = client.sender();\n// Get a WebSocketFragmentSerializer\nlet mut fragment = sender.fragment();\n \nlet message1 = WebSocketMessage::Text(\"This \".to_string());\nlet message2 = WebSocketMessage::Text(\"is \".to_string());\nlet message3 = WebSocketMessage::Text(\"a \".to_string());\nlet message4 = WebSocketMessage::Text(\"fragmented \".to_string());\nlet message5 = WebSocketMessage::Text(\"message.\".to_string());\n \n// Send our fragments\nfragment.send_fragment(&message1); // Each one is sent immediately\nfragment.send_fragment(&message2);\nfragment.send_fragment(&message3);\nfragment.send_fragment(&message4);\n \n// Now tell them we're done\nfragment.finish(&message1); // Now they'll assemble the fragments into a single message\n \n// Drop this WebSocketFragmentSerializer, or let it go out of scope\ndrop(fragment);\n# }\n```"],[1,"WebSocketReceiver","","Represents a WebSocket receiver which can receive data from the remote endpoint.\nAll methods are task blocking (but not stream blocking, so you can send and receive concurrently).\nA WebSocketReceiver can be captured into another task for concurrency"],[1,"IncomingMessages","","An iterator over incoming messages. Blocks the task and always returns Some."],[2,"WebSocketMessage","","Represents a WebSocket message. When receiving messages, the resulting\nmessages are always entire messages (never fragments). You are able to, \nhowever, send messages as fragments using a WebSocketFragmentSerializer. \nThese messages will be sent to the remote endpoint and reassembled into\na single message."],[12,"Text","","A message containing UTF-8 text data",20],[12,"Binary","","A message containing binary data",20],[12,"Close","","A message which indicates closure of the WebSocket connection.\nThis message may or may not contain data",20],[12,"Ping","","A ping message - should be responded to with a pong message.\nUsually the pong message will be sent with the same data as the\nreceived ping message.",20],[12,"Pong","","A pong message",20],[10,"new","websocket::headers","Creates a new HeaderCollection",21],[10,"insert","","Add the given field-value pair to the collection. If the field is already present,\nthe value is appended to the header using comma-separation. Field names are case-insensitive.",21],[10,"contains_field","","Returns true when the specified case-insensitive field name exists in the HeaderCollection.",21],[10,"get","","Gets the value of the header with the specified case-insensitive field name.",21],[10,"remove","","Removes the header with the specified field name from the HeaderCollection.",21],[10,"iter","","Returns an iterator which iterates over each header in the HeaderCollection.",21],[10,"clone","","",21],[10,"next","","",22],[10,"new","websocket::handshake","Creates a new WebSocket handshake request for use with WebSocketClient::connect().\nThe URI should use the ws:// or wss:// scheme.",17],[10,"host","","Short-cut to get the Host field value of this request",17],[10,"connection","","Short-cut to get the Connection field value of this request",17],[10,"upgrade","","Short-cut to get the Upgrade field value of this request",17],[10,"version","","Short-cut to get the Sec-WebSocket-Version field value of this request",17],[10,"key","","Short-cut to get the Sec-WebSocket-Key field value of this request",17],[10,"protocol","","Short-cut to get the Sec-WebSocket-Protocol field value of this request",17],[10,"extensions","","Short-cut to get the Sec-WebSocket-Extensions field value of this request",17],[10,"origin","","Short-cut to get the Origin field value of this request",17],[10,"clone","","",17],[10,"new","","Create a new WebSocket response based on the base-64 encoded key from a client.",18],[10,"failure","","Create a WebSocket response with a particular status code and reason phrase - generally\nused to indicate a handshake failure.",18],[10,"upgrade","","Short-cut to get the Upgrade field value of this request",18],[10,"connection","","Short-cut to get the Connection field value of this request",18],[10,"accept","","Short-cut to get the Sec-WebSocket-Accept field value of this request",18],[10,"protocol","","Short-cut to get the Sec-WebSocket-Protocol field value of this request",18],[10,"version","","Short-cut to get the Sec-WebSocket-Version field value of this request\nThis may be present when the handshake fails (it should not appear on a successful\nhandshake response.",18],[10,"extensions","","Short-cut to get the Sec-WebSocket-Extensions field value of this request",18],[10,"gen_accept","","Generates the handshake Sec-WebSocket-Accept value from\nthe given Sec-WebSocket-Key.",18],[10,"is_successful","","Returns true if this response indicates a successful handshake\n \nThe status code must be 101, the WebSocket-Version must be 13,\nthe Upgrade must be 'websocket', the Connection must be 'Upgrade',\nthe Sec-WebSocket-Accept header must match the expected value from\nthe given key.",18],[10,"clone","","",18],[10,"clone","","",19],[10,"new","","Create a new HttpVersion from major and minor version numbers.",19],[10,"parse","","Create a new HttpVersion from a string. Panics if unable to parse the string.",19],[10,"fmt","","",19],[10,"new","websocket","Creates a new WebSocketClient from a given cloneable stream.\nThe mask parameter determines whether or not messages send to the remote endpoint will be masked.\nIf the client is connecting to a remote endpoint, set mask to true. If the client is the remote\nendpoint (and therefore, the server is the local endpoint), set mask to false.\n \nNothing is sent to or read from the stream during the conversion.",23],[10,"stream","","Returns a copy of the underlying S for this WebSocketClient.\nNote that writing to this stream will likely invalidate the WebSocket data stream.",23],[10,"receive_handshake_request","","Reads a request from this client. Only to be used if the server is the local endpoint and\nthe client is the remote endpoint.",23],[10,"receive_handshake_response","","Reads a response that was sent to this client. Only to be used if the server is the remote\nendpoint and the client is the local endpoint.",23],[10,"send_handshake_request","","Sends the specified WebSocketRequest to the remote endpoint. Only to be used if the server is\nthe remote endpoint and the client is the local endpoint.",23],[10,"send_handshake_response","","Sends the specified WebSocketResponse to this client. Only to be used if the server is\nthe local endpoint and the client is the remote endpoint.",23],[10,"sender","","Returns a WebSocketSender from this client. Used to transmit data to the remote endpoint,\nthat is, to the server if WebSocketClient::connect() has been used, or to this client otherwise.",23],[10,"receiver","","Returns a WebSocketReceiver from this client. Used to receive data from the remote endpoint,\nthat is, from the server if WebSocketClient::connect() has been used, or from this client otherwise.",23],[10,"clone","","",23],[10,"send_message","websocket::message","Sends a message to the remote endpoint.",24],[10,"fragment","","Returns a fragment serializer, able to send fragments of a message to the remote endpoint.",24],[10,"send_fragment","","Send a fragment of a message - if the message is finished, use the WebSocketFragmentSerializer::finish() function.\nCan only be used with a Text or Binary message.",25],[10,"finish","","Send the final message and tell the remote endpoint the message is complete. Can be used with an empty message if necessary.\nCan only be used with a Text or Binary message.\n \nOnce this has been called, you can send a new fragmented message using the send_fragment() method.",25],[10,"receive_message","","Wait for and accept a message (subjected to the underlying stream timeout).\nIf the received message is fragmented, this function will not return\nuntil the final fragment has been received.\nIf a control frame is received interleaved within a fragmented message,\nThe control frame will be returned first, and the message will be returned\non the next call to the function (or later if more control frames are received).",26],[10,"incoming","","Returns an iterator over the incoming messages for/from this client",26],[10,"next","","",27],[10,"fmt","","",20],[10,"new","websocket::handshake","Creates a new WebSocket handshake request for use with WebSocketClient::connect().\nThe URI should use the ws:// or wss:// scheme.",17],[10,"host","","Short-cut to get the Host field value of this request",17],[10,"connection","","Short-cut to get the Connection field value of this request",17],[10,"upgrade","","Short-cut to get the Upgrade field value of this request",17],[10,"version","","Short-cut to get the Sec-WebSocket-Version field value of this request",17],[10,"key","","Short-cut to get the Sec-WebSocket-Key field value of this request",17],[10,"protocol","","Short-cut to get the Sec-WebSocket-Protocol field value of this request",17],[10,"extensions","","Short-cut to get the Sec-WebSocket-Extensions field value of this request",17],[10,"origin","","Short-cut to get the Origin field value of this request",17],[10,"clone","","",17],[10,"new","","Create a new WebSocket response based on the base-64 encoded key from a client.",18],[10,"failure","","Create a WebSocket response with a particular status code and reason phrase - generally\nused to indicate a handshake failure.",18],[10,"upgrade","","Short-cut to get the Upgrade field value of this request",18],[10,"connection","","Short-cut to get the Connection field value of this request",18],[10,"accept","","Short-cut to get the Sec-WebSocket-Accept field value of this request",18],[10,"protocol","","Short-cut to get the Sec-WebSocket-Protocol field value of this request",18],[10,"version","","Short-cut to get the Sec-WebSocket-Version field value of this request\nThis may be present when the handshake fails (it should not appear on a successful\nhandshake response.",18],[10,"extensions","","Short-cut to get the Sec-WebSocket-Extensions field value of this request",18],[10,"gen_accept","","Generates the handshake Sec-WebSocket-Accept value from\nthe given Sec-WebSocket-Key.",18],[10,"is_successful","","Returns true if this response indicates a successful handshake\n \nThe status code must be 101, the WebSocket-Version must be 13,\nthe Upgrade must be 'websocket', the Connection must be 'Upgrade',\nthe Sec-WebSocket-Accept header must match the expected value from\nthe given key.",18],[10,"clone","","",18],[10,"clone","","",19],[10,"new","","Create a new HttpVersion from major and minor version numbers.",19],[10,"parse","","Create a new HttpVersion from a string. Panics if unable to parse the string.",19],[10,"fmt","","",19],[10,"new","websocket","Creates a new WebSocketClient from a given cloneable stream.\nThe mask parameter determines whether or not messages send to the remote endpoint will be masked.\nIf the client is connecting to a remote endpoint, set mask to true. If the client is the remote\nendpoint (and therefore, the server is the local endpoint), set mask to false.\n \nNothing is sent to or read from the stream during the conversion.",23],[10,"stream","","Returns a copy of the underlying S for this WebSocketClient.\nNote that writing to this stream will likely invalidate the WebSocket data stream.",23],[10,"receive_handshake_request","","Reads a request from this client. Only to be used if the server is the local endpoint and\nthe client is the remote endpoint.",23],[10,"receive_handshake_response","","Reads a response that was sent to this client. Only to be used if the server is the remote\nendpoint and the client is the local endpoint.",23],[10,"send_handshake_request","","Sends the specified WebSocketRequest to the remote endpoint. Only to be used if the server is\nthe remote endpoint and the client is the local endpoint.",23],[10,"send_handshake_response","","Sends the specified WebSocketResponse to this client. Only to be used if the server is\nthe local endpoint and the client is the remote endpoint.",23],[10,"sender","","Returns a WebSocketSender from this client. Used to transmit data to the remote endpoint,\nthat is, to the server if WebSocketClient::connect() has been used, or to this client otherwise.",23],[10,"receiver","","Returns a WebSocketReceiver from this client. Used to receive data from the remote endpoint,\nthat is, from the server if WebSocketClient::connect() has been used, or from this client otherwise.",23],[10,"clone","","",23],[10,"new","websocket::headers","Creates a new HeaderCollection",21],[10,"insert","","Add the given field-value pair to the collection. If the field is already present,\nthe value is appended to the header using comma-separation. Field names are case-insensitive.",21],[10,"contains_field","","Returns true when the specified case-insensitive field name exists in the HeaderCollection.",21],[10,"get","","Gets the value of the header with the specified case-insensitive field name.",21],[10,"remove","","Removes the header with the specified field name from the HeaderCollection.",21],[10,"iter","","Returns an iterator which iterates over each header in the HeaderCollection.",21],[10,"clone","","",21],[10,"next","","",22]],"paths":[[2,"WebSocketClientMode"],[1,"EncodingOverride"],[2,"Host"],[1,"Ipv6Address"],[2,"ParseError"],[2,"Context"],[1,"CharRanges"],[1,"PathFormatter"],[1,"UserInfoFormatter"],[1,"UrlNoFragmentFormatter"],[1,"Url"],[2,"SchemeData"],[1,"RelativeSchemeData"],[1,"UrlParser"],[2,"SchemeType"],[1,"Path"],[1,"Path"],[1,"WebSocketRequest"],[1,"WebSocketResponse"],[1,"HttpVersion"],[2,"WebSocketMessage"],[1,"HeaderCollection"],[1,"Headers"],[1,"WebSocketClient"],[1,"WebSocketSender"],[1,"WebSocketFragmentSerializer"],[1,"WebSocketReceiver"],[1,"IncomingMessages"]]};
initSearch(searchIndex);
