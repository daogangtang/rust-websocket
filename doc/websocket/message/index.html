<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="rustdoc">
    <meta name="description" content="API documentation for the Rust `message` mod in crate `websocket`.">
    <meta name="keywords" content="rust, rustlang, rust-lang, message">

    <title>websocket::message - Rust</title>

    <link rel="stylesheet" type="text/css" href="../../main.css">

    
    
</head>
<body class="rustdoc">
    <!--[if lte IE 8]>
    <div class="warning">
        This old browser is unsupported and will most likely display funky
        things.
    </div>
    <![endif]-->

    

    <section class="sidebar">
        
        <p class='location'><a href='../index.html'>websocket</a></p><div class='block mod'><h2>Modules</h2><a class='mod ' href='../handshake/index.html'>handshake</a><a class='mod ' href='../headers/index.html'>headers</a><a class='mod current' href='../message/index.html'>message</a></div><div class='block struct'><h2>Structs</h2><a class='struct ' href='../struct.WebSocketClient.html'>WebSocketClient</a></div><div class='block enum'><h2>Enums</h2><a class='enum ' href='../enum.WebSocketClientMode.html'>WebSocketClientMode</a></div>
    </section>

    <nav class="sub">
        <form class="search-form js-only">
            <div class="search-container">
                <input class="search-input" name="search"
                       autocomplete="off"
                       placeholder="Click or press 'S' to search, '?' for more options..."
                       type="search">
            </div>
        </form>
    </nav>

    <section id='main' class="content mod">
<h1 class='fqn'><span class='in-band'>Module <a href='../index.html'>websocket</a>::<wbr><a class='mod' href=''>message</a><wbr></span><span class='out-of-band'><span id='render-detail'>
            <a id="collapse-all" href="#">[-]
            </a>&nbsp;<a id="expand-all" href="#">[+]</a>
        </span><a id='src-23' href='../../src/websocket/Users/Jason/Documents/GitHub/rust-websocket/src/lib.rs.html#80-84'>[src]</a></span></h1>
<div class='docblock'><p>Structs for WebSocket messages and the transmission of messages</p>
</div><h2 id='structs' class='section-header'><a href="#structs">Structs</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='struct' href='struct.IncomingMessages.html'
                               title='websocket::message::IncomingMessages'>IncomingMessages</a></td>
                        <td class='docblock short'><p>An iterator over incoming messages. Blocks the task and always returns Some.</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='struct' href='struct.WebSocketFragmentSerializer.html'
                               title='websocket::message::WebSocketFragmentSerializer'>WebSocketFragmentSerializer</a></td>
                        <td class='docblock short'><p>Allows for the serialization of message fragments, to be sent to the remote endpoint.
Any number of messages can be sent (but only text or binary messages, as control
messages can never be fragmented) using the send_fragment() method, and when the final
fragment is to be sent, use the finish() method. After calling the finish method, the
remote endpoint will assemble all of the received message fragments into a single
message containing all of the fragment data concatenated together.</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>websocket</span>::<span class='ident'>message</span>::<span class='ident'>WebSocketMessage</span>;
<span class='comment'>// Get a WebSocketFragmentSerializer</span>
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>fragment</span> <span class='op'>=</span> <span class='ident'>sender</span>.<span class='ident'>fragment</span>();
 
<span class='kw'>let</span> <span class='ident'>message1</span> <span class='op'>=</span> <span class='ident'>WebSocketMessage</span>::<span class='ident'>Text</span>(<span class='string'>&quot;This &quot;</span>.<span class='ident'>to_string</span>());
<span class='kw'>let</span> <span class='ident'>message2</span> <span class='op'>=</span> <span class='ident'>WebSocketMessage</span>::<span class='ident'>Text</span>(<span class='string'>&quot;is &quot;</span>.<span class='ident'>to_string</span>());
<span class='kw'>let</span> <span class='ident'>message3</span> <span class='op'>=</span> <span class='ident'>WebSocketMessage</span>::<span class='ident'>Text</span>(<span class='string'>&quot;a &quot;</span>.<span class='ident'>to_string</span>());
<span class='kw'>let</span> <span class='ident'>message4</span> <span class='op'>=</span> <span class='ident'>WebSocketMessage</span>::<span class='ident'>Text</span>(<span class='string'>&quot;fragmented &quot;</span>.<span class='ident'>to_string</span>());
<span class='kw'>let</span> <span class='ident'>message5</span> <span class='op'>=</span> <span class='ident'>WebSocketMessage</span>::<span class='ident'>Text</span>(<span class='string'>&quot;message.&quot;</span>.<span class='ident'>to_string</span>());
 
<span class='comment'>// Send our fragments</span>
<span class='ident'>fragment</span>.<span class='ident'>send_fragment</span>(<span class='kw-2'>&amp;</span><span class='ident'>message1</span>); <span class='comment'>// Each one is sent immediately</span>
<span class='ident'>fragment</span>.<span class='ident'>send_fragment</span>(<span class='kw-2'>&amp;</span><span class='ident'>message2</span>);
<span class='ident'>fragment</span>.<span class='ident'>send_fragment</span>(<span class='kw-2'>&amp;</span><span class='ident'>message3</span>);
<span class='ident'>fragment</span>.<span class='ident'>send_fragment</span>(<span class='kw-2'>&amp;</span><span class='ident'>message4</span>);
 
<span class='comment'>// Now tell them we&#39;re done</span>
<span class='ident'>fragment</span>.<span class='ident'>finish</span>(<span class='kw-2'>&amp;</span><span class='ident'>message1</span>); <span class='comment'>// Now they&#39;ll assemble the fragments into a single message</span>
 
<span class='comment'>// Drop this WebSocketFragmentSerializer, or let it go out of scope</span>
<span class='ident'>drop</span>(<span class='ident'>fragment</span>);
</pre>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='struct' href='struct.WebSocketReceiver.html'
                               title='websocket::message::WebSocketReceiver'>WebSocketReceiver</a></td>
                        <td class='docblock short'><p>Represents a WebSocket receiver which can receive data from the remote endpoint.
All methods are task blocking (but not stream blocking, so you can send and receive concurrently).
A WebSocketReceiver can be captured into another task for concurrency</p>
</td>
                    </tr>
                
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='struct' href='struct.WebSocketSender.html'
                               title='websocket::message::WebSocketSender'>WebSocketSender</a></td>
                        <td class='docblock short'><p>Represents a WebSocket sender, capable of transmitting data to the remote endpoint.
Use the send_message() method to send a single, whole message. If you need to send
a series of message fragments (e.g. if you need to send a message of unknown length),
use the fragment() method to obtain a WebSocketFragmentSerializer, which can be
used to do so.</p>
<pre class='rust '>
<span class='kw'>use</span> <span class='ident'>websocket</span>::<span class='ident'>message</span>::<span class='ident'>WebSocketMessage</span>;
 
<span class='kw'>let</span> <span class='kw-2'>mut</span> <span class='ident'>sender</span> <span class='op'>=</span> <span class='ident'>client</span>.<span class='ident'>sender</span>(); <span class='comment'>// Get a sender</span>
<span class='kw'>let</span> <span class='ident'>data</span> <span class='op'>=</span> <span class='string'>&quot;My fancy message&quot;</span>.<span class='ident'>to_string</span>();
<span class='kw'>let</span> <span class='ident'>message</span> <span class='op'>=</span> <span class='ident'>WebSocketMessage</span>::<span class='ident'>Text</span>(<span class='ident'>data</span>.<span class='ident'>to_string</span>());
 
<span class='kw'>let</span> _ <span class='op'>=</span> <span class='ident'>sender</span>.<span class='ident'>send_message</span>(<span class='kw-2'>&amp;</span><span class='ident'>message</span>); <span class='comment'>// Send the message</span>
</pre>
</td>
                    </tr>
                </table><h2 id='enums' class='section-header'><a href="#enums">Enums</a></h2>
<table>
                    <tr>
                        <td><a class='stability Unmarked' title='No stability level'></a><a class='enum' href='enum.WebSocketMessage.html'
                               title='websocket::message::WebSocketMessage'>WebSocketMessage</a></td>
                        <td class='docblock short'><p>Represents a WebSocket message. When receiving messages, the resulting
messages are always entire messages (never fragments). You are able to, 
however, send messages as fragments using a WebSocketFragmentSerializer. 
These messages will be sent to the remote endpoint and reassembled into
a single message.</p>
</td>
                    </tr>
                </table></section>
    <section id='search' class="content hidden"></section>

    <section class="footer"></section>

    <div id="help" class="hidden">
        <div class="shortcuts">
            <h1>Keyboard shortcuts</h1>
            <dl>
                <dt>?</dt>
                <dd>Show this help dialog</dd>
                <dt>S</dt>
                <dd>Focus the search field</dd>
                <dt>&larrb;</dt>
                <dd>Move up in search results</dd>
                <dt>&rarrb;</dt>
                <dd>Move down in search results</dd>
                <dt>&#9166;</dt>
                <dd>Go to active search result</dd>
            </dl>
        </div>
        <div class="infos">
            <h1>Search tricks</h1>
            <p>
                Prefix searches with a type followed by a colon (e.g.
                <code>fn:</code>) to restrict the search to a given type.
            </p>
            <p>
                Accepted types are: <code>fn</code>, <code>mod</code>,
                <code>struct</code>, <code>enum</code>,
                <code>trait</code>, <code>typedef</code> (or
                <code>tdef</code>).
            </p>
        </div>
    </div>

    

    <script>
        window.rootPath = "../../";
        window.currentCrate = "websocket";
        window.playgroundUrl = "";
    </script>
    <script src="../../jquery.js"></script>
    <script src="../../main.js"></script>
    
    <script async src="../../search-index.js"></script>
</body>
</html>